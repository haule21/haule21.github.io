---
layout: posts
permalink: /:categories/:title
title: "객체 지향 설계 5원칙 - SOLID"
categories: java
---

SOLID는 아래 5가지 원칙 앞 머리 알파벳을 따서 부르는 이름이다.

`SRP(Single Responsbility Principle) : 단일 책임 원칙`
데이터베이스에서의 제 2정규화 원칙과 비슷하다.

사람 이라는 클래스를 만든다고 하면
나라는 객체를 만들어 낼 수 있다.

하지만 나라는 클래스로 내 친구 A를 만들어 내는 것은 어려운 일이다.
왜냐하면 나에게만 있는 특징들이 있기 때문이다.

이렇듯 단일 책임 원칙은 상위 클래스 에게 종속 돼야 한다는 원칙이다.
다음은 단일 책임 원칙을 지키지 않은 경우이다.
```java
class me{

  final static Boolean man = true;
  final static Boolean woman = false;
  Boolean gender;
  
  void 화장실가기(){
    if(this.gender == man){
      // 남자 화장실로 간다.
    }
    else{
      // 여자 화장실로 간다.
    }
  }
}
```
다음은 단일 책임 원칙을 적용한 코드이다.
```java
abstract class person{
  abstract void 화장실가기()
}

class 남자 extends person {
  void 화장실가기(){
    // 남자 화장실로 간다.
  }
}

class 여자 extends person {
  void 화장실가기(){
    // 여자 화장실로 간다.
  }
}

```

`OCP(Open Closed Principle) : 개방 폐쇄 원칙`
확장에 대해서는 열려있지만 변경에 대해서는 닫혀 있어야 한다.

다음은 개방 폐쇄 원칙에 위배 되는 경우를 알아보자.

`여자친구를 사귀었다. 그 여자친구는 운동을 좋아해 우리는 헬스장 데이트 메소드를 사용하여 데이트를 했다.
그리고 여자친구가 닭 가슴살을 좋아해서 우리는 닭 가슴살 먹기 메소드를 사용하여 식사를 했다.
어느 날 나와의 만남이 근손실이 난다며 헤어지자고 통보했고 난 얼마 뒤 나는 새로운 여자친구를 사귀었다.
그 여자친구는 애니메이션이나 영화를 좋아해 넷플릭스 데이트 메소드를 사용하여 데이트를 했다.
그리고 여자친구는 파스타를 좋아해 파스타 먹기 메소드를 사용하여 식사를 했다.'

[나] -> [구 여자친구/ 헬스장 데이트(), 닭 가슴살 먹기] 
[나] -> [신 여자친구/ 넷플릭스 데이트(), 파스타 먹기]

이렇게 매번 새로운 여자친구를 사귈 때마다 새로운 메소드를 적용 해야 하는게 어간 귀찮은 일이 아니다.

그래서 중간에 [나] -> [여자친구/ 데이트(), 식사하기()] 라는 상위 클래스나 인터페이스를 둠으로써 
데이트나 식사하는 것에 있어 조작에 영향을 받지 않게 된다.

여자친구 확장에는 개방 돼 있지만, 나의 입장에서는 주변의 변화에 폐쇄 돼 있는 것이다.

```java
class 나{
  I여자친구 여자친구;
}
public interface I여자친구{
  데이트하기()
  식사하기()
}
class 구여자친구 implements I여자친구{
  데이트하기(){
    // 헬스장 데이트 하기
  }
  식사하기(){
    // 닭 가슴살 먹기
  }
}
class 신여자친구 implements I여자친구{
  데이트하기(){
    // 넷플릭스 데이트 하기
  }
  식사하기(){
    // 파스타 먹기
  }
}
```

`LSP(Liskov Substituion Principle) : 리스코프 치환 원칙`
리스코프 치환은 하위 분류는 상위 분류의 한 종류 여야 한다는 원칙이다.


예를 들어 `할아버지 -> 아버지 -> 나` 일 경우 아버지는 할아버지의 아래 소속 된 것 뿐이지 할아버지로 분류 될 수 없다.
`동물 -> 포유류 -> 고래` 일 경우 포유류는 동물에 분류 될 수 있고, 고래 또한 포유류로 분류 될 수 있다.




`ISP(Interface Segregation Principle) : 인터페이스 분리 원칙`
인터페이스 분리 원칙은 간단하다.
나라는 클래스에서 강아지를 위한 쓰다듬는 메소드와 직장상사를 위한 인사하는 메소드가 있다고 생각해보자.

`어느 날 메소드를 잘못 불러와 직장상사에게 쓰다듬는 메소드를 실행하게 될 경우에는 문제가 있을 수 있다. (예외적으로 아닐 수도 있겠지만..)`

그래서 인터페이스로 제한을 해야 된다는 원칙이다.
직장상사는 직장상사의 인터페이스로 분리하여 사용하고 강아지는 강아지의 인터페이스로 분리하여 사용해야 된다는 이야기다.

`DIP(Dependency Inversion Principle) : 의존 역전 원칙`
의존 역전 원칙은 자주 변하는 것에 의존하면 안 된다는 원칙이다.
OCP(개방 폐쇄 원칙)과 비슷한 양상을 띤다.

위의 예시를 따라 설명 하자면
`(구) 여자친구를 여자친구라는 추상적 개념으로 생각해서는 안 된다.
여자친구라는 추상적 개념에 대해서 구 여자친구를 떠올릴 수 있다..
(신) 여자친구를 여자친구라는 추상적 개념으로 생각해서는 안 된다.
여자친구라는 추상적 개념에 대해서 신 여자친구를 떠올릴 수 있다.`

요약 하자면 `상위 클래스, 인터페이스, 추상클래스` 일 수록 변하지 않을 가능성이 높기 때문에
`하위 클래스나 구체 클래스`가 아닌 `상위 클래스, 인터페이스, 추상클래스`에 의존하라는 것이 바로 의존 역전 원칙이다.


응집도는 높이고(High Cohesion) 결합도는 낮추라(Loose Coupling)는 고전 원칙을 객체 지향의 관점에서 재정립 한 것이라고 볼 수 있다.


디자인 패턴의 활용으로 알아보자.
'어댑터 패턴 - OCP'
`템플릿 메서드 패턴 - DIP`
`프록시 패턴 - OCP, DIP'
'데코레이터 패턴 - OCP, DIP'
`팩터리 메소드 패턴 - DIP`
`전략 패턴 - OCP, DIP`
`템플릿 콜백 패턴 - OCP, DIP`

그 외의 싱글턴 패턴이 있다.

다음 포스트에서 알아보자




